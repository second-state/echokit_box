<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setup EchoKit</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>

<body class="bg-base-200 min-h-screen py-8 bg-cover bg-center bg-no-repeat bg-fixed">
    <div class="container mx-auto px-4 max-w-4xl">
        <div class="card bg-base-100 shadow-xl">
            <div class="card-body">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="card-title text-2xl">Setup EchoKit via Bluetooth</h2>
                    <div class="flex items-center gap-2">
                        <span class="badge badge-error" id="statusIndicator">‚óè</span>
                        <span id="connectionStatus">Disconnected</span>
                    </div>
                </div>

                <button class="btn btn-primary w-full mb-4" id="connectButton">
                    Connect to EchoKit
                </button>

                <div id="controlPanel" class="space-y-4">
                    <div class="flex gap-2">
                        <button class="btn btn-outline flex-1" id="loadAllButton">
                            üîÑ Load Configuration
                        </button>
                        <button class="btn btn-primary flex-1" id="saveAllButton" disabled>
                            üíæ Save Changes
                        </button>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg" id="ssidTitle">WiFi (MUST be 2.4GHz)</h3>
                            <label class="form-control">
                                <div class="label">
                                    <span class="label-text">Network Name</span>
                                </div>
                                <input type="text" id="ssidInput" placeholder="WiFi network name SSID"
                                    class="input input-bordered w-full">
                            </label>
                            <label class="form-control">
                                <div class="label">
                                    <span class="label-text">Password</span>
                                </div>
                                <input type="password" id="passInput" placeholder="WiFi Password"
                                    class="input input-bordered w-full">
                            </label>
                        </div>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg" id="urlTitle">EchoKit Server</h3>
                            <label class="form-control">
                                <div class="label">
                                    <span class="label-text">WebSocket URL</span>
                                </div>
                                <input type="text" id="serverUrlInput" placeholder="EchoKit server WebSocket URL"
                                    class="input input-bordered w-full">
                            </label>
                        </div>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg">Background Image</h3>
                            <div class="form-control mb-4">
                                <label class="label">
                                    <span class="label-text">Select a background image (GIF)</span>
                                </label>
                                <input type="file" class="file-input file-input-bordered w-full" id="backgroundImage"
                                    accept=".gif" onchange="validateAndPreviewFile(this)">
                                <label class="label">
                                    <span class="label-text-alt">Must be a GIF file, max 1MB</span>
                                </label>
                                <div id="fileError" class="text-error text-sm"></div>
                                <div id="bgPreview"
                                    class="hidden mt-2 w-24 h-16 rounded border border-base-300 bg-cover bg-center">
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button class="btn btn-primary flex-1" id="writeBgButton" disabled>Set
                                    Background</button>
                                <button class="btn btn-outline flex-1" id="clearBgButton">Clear Background</button>
                            </div>
                        </div>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg">Avatar Image</h3>
                            <div class="form-control mb-4">
                                <label class="label">
                                    <span class="label-text">Select an avatar image (GIF)</span>
                                </label>
                                <input type="file" class="file-input file-input-bordered w-full" id="avatarImage"
                                    accept=".gif" onchange="validateAndPreviewAvatarFile(this)">
                                <label class="label">
                                    <span class="label-text-alt">Must be a GIF file, max 128KB</span>
                                </label>
                                <div id="avatarFileError" class="text-error text-sm"></div>
                                <div id="avatarPreview"
                                    class="hidden mt-2 w-16 h-16 rounded border border-base-300 bg-cover bg-center">
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button class="btn btn-primary flex-1" id="writeAvatarButton" disabled>Set
                                    Avatar</button>
                                <button class="btn btn-outline flex-1" id="clearAvatarButton">Clear Avatar</button>
                            </div>
                        </div>
                    </div>

                    <!-- Advanced Settings Collapse Panel -->
                    <div class="collapse collapse-arrow bg-base-200 border border-base-300">
                        <input type="checkbox" id="advancedSettingsToggle" />
                        <div class="collapse-title text-lg font-medium">
                            üõ†Ô∏è Advanced Settings
                        </div>
                        <div class="collapse-content">
                            <div class="space-y-4 pt-4">
                                <!-- AFE Linear Gain -->
                                <div class="card bg-base-100 border border-base-300">
                                    <div class="card-body py-4">
                                        <h4 class="card-title text-base" id="afeLinearGainTitle">AFE Linear Gain</h4>
                                        <label class="form-control">
                                            <div class="label">
                                                <span class="label-text">Linear gain value (0.1 - 3.0)</span>
                                                <span class="badge badge-primary" id="afeLinearGainValue">1.5</span>
                                            </div>
                                            <input type="range" min="1" max="30" value="15" class="range range-sm"
                                                id="afeLinearGainRange" />
                                        </label>
                                        <button class="btn btn-sm btn-outline mt-2" id="saveAfeLinearGainButton"
                                            disabled>
                                            Save AFE Linear Gain
                                        </button>
                                    </div>
                                </div>

                                <!-- AGC Target Level -->
                                <div class="card bg-base-100 border border-base-300">
                                    <div class="card-body py-4">
                                        <h4 class="card-title text-base" id="agcTargetLevelTitle">AGC Target Level</h4>
                                        <label class="form-control">
                                            <div class="label">
                                                <span class="label-text">Target level (dBFS, 0 - 32)</span>
                                                <span class="badge badge-primary" id="agcTargetLevelValue">1</span>
                                            </div>
                                            <input type="range" min="0" max="32" value="1" class="range range-sm"
                                                id="agcTargetLevelRange" />
                                        </label>
                                        <button class="btn btn-sm btn-outline mt-2" id="saveAgcTargetLevelButton"
                                            disabled>
                                            Save AGC Target Level
                                        </button>
                                    </div>
                                </div>

                                <!-- AGC Compression Gain -->
                                <div class="card bg-base-100 border border-base-300">
                                    <div class="card-body py-4">
                                        <h4 class="card-title text-base" id="agcCompressionGainTitle">AGC Compression
                                            Gain</h4>
                                        <label class="form-control">
                                            <div class="label">
                                                <span class="label-text">Compression gain (dB, 0 - 32)</span>
                                                <span class="badge badge-primary" id="agcCompressionGainValue">15</span>
                                            </div>
                                            <input type="range" min="0" max="32" value="15" class="range range-sm"
                                                id="agcCompressionGainRange" />
                                        </label>
                                        <button class="btn btn-sm btn-outline mt-2" id="saveAgcCompressionGainButton"
                                            disabled>
                                            Save AGC Compression Gain
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification toast -->
    <div class="toast toast-top toast-end z-50" id="toastContainer">
        <div class="alert" id="notificationToast" style="display: none;">
            <span id="toastMessage">Message content</span>
        </div>
    </div>

    <!-- Reset not supported modal dialog -->
    <dialog id="resetNotSupportedModal" class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">‚ö†Ô∏è Device Reset Required</h3>
            <p class="py-4">Please press the k0 key on the device to restart it.</p>
            <div class="modal-action">
                <form method="dialog">
                    <button class="btn btn-primary">OK</button>
                </form>
            </div>
        </div>
    </dialog>

    <script>
        // UUIDs
        const SERVICE_ID = "623fa3e2-631b-4f8f-a6e7-a7b09c03e7e0";
        const SSID_ID = "1fda4d6e-2f14-42b0-96fa-453bed238375";
        const PASS_ID = "a987ab18-a940-421a-a1d7-b94ee22bccbe";
        const SERVER_URL_ID = "cef520a9-bcb5-4fc6-87f7-82804eee2b20";
        const BACKGROUND_IMAGE_ID = "d1f3b2c4-5e6f-4a7b-8c9d-0e1f2a3b4c5d";
        const AVATAR_IMAGE_ID = "e2f4c3b5-6d7e-4f8a-9b0c-1f2e3d4c5b6a";
        const RESET_ID = "f0e1d2c3-b4a5-6789-0abc-def123456789";
        const AFE_LINEAR_GAIN_ID = "a1b2c3d4-e5f6-4789-0abc-def123456789";
        const AGC_TARGET_LEVEL_ID = "b2c3d4e5-f6a7-4890-1bcd-ef2345678901";
        const AGC_COMPRESSION_GAIN_ID = "c3d4e5f6-a7b8-4901-2cde-f34567890123";

        // global variables
        let device = null;
        let server = null;
        let service = null;
        let isConnected = false;
        let toast = null;
        let selectedBackgroundFile = null;
        let selectedAvatarFile = null;

        // DOM
        const connectButton = document.getElementById('connectButton');
        const controlPanel = document.getElementById('controlPanel');
        const statusIndicator = document.getElementById('statusIndicator');
        const connectionStatus = document.getElementById('connectionStatus');
        const loadAllButton = document.getElementById('loadAllButton');
        const saveAllButton = document.getElementById('saveAllButton');
        const ssidInput = document.getElementById('ssidInput');
        const passInput = document.getElementById('passInput');
        const serverUrlInput = document.getElementById('serverUrlInput');
        const ssidTitle = document.getElementById('ssidTitle');
        const passTitle = document.getElementById('passTitle');
        const urlTitle = document.getElementById('urlTitle');
        const backgroundImage = document.getElementById('backgroundImage');
        const bgPreview = document.getElementById('bgPreview');
        const fileError = document.getElementById('fileError');
        const writeBgButton = document.getElementById('writeBgButton');
        const clearBgButton = document.getElementById('clearBgButton');
        const avatarImage = document.getElementById('avatarImage');
        const avatarPreview = document.getElementById('avatarPreview');
        const avatarFileError = document.getElementById('avatarFileError');
        const writeAvatarButton = document.getElementById('writeAvatarButton');
        const clearAvatarButton = document.getElementById('clearAvatarButton');
        const notificationToast = document.getElementById('notificationToast');
        const toastMessage = document.getElementById('toastMessage');
        const resetNotSupportedModal = document.getElementById('resetNotSupportedModal');

        // AFE related DOM elements
        const afeLinearGainRange = document.getElementById('afeLinearGainRange');
        const afeLinearGainValue = document.getElementById('afeLinearGainValue');
        const saveAfeLinearGainButton = document.getElementById('saveAfeLinearGainButton');
        const afeLinearGainTitle = document.getElementById('afeLinearGainTitle');

        const agcTargetLevelRange = document.getElementById('agcTargetLevelRange');
        const agcTargetLevelValue = document.getElementById('agcTargetLevelValue');
        const saveAgcTargetLevelButton = document.getElementById('saveAgcTargetLevelButton');
        const agcTargetLevelTitle = document.getElementById('agcTargetLevelTitle');

        const agcCompressionGainRange = document.getElementById('agcCompressionGainRange');
        const agcCompressionGainValue = document.getElementById('agcCompressionGainValue');
        const saveAgcCompressionGainButton = document.getElementById('saveAgcCompressionGainButton');
        const agcCompressionGainTitle = document.getElementById('agcCompressionGainTitle');

        // Track modified fields
        const modifiedFields = {
            ssid: false,
            pass: false,
            url: false
        };

        // Mark field as modified
        function markFieldAsModified(fieldName, titleElement) {
            modifiedFields[fieldName] = true;
            if (!titleElement.textContent.endsWith(' *')) {
                titleElement.textContent += ' *';
            }
            updateSaveButtonState();
        }

        // Clear field modification mark
        function clearFieldModification(fieldName, titleElement) {
            modifiedFields[fieldName] = false;
            if (titleElement) {
                titleElement.textContent = titleElement.textContent.replace(' *', '');
            }
            updateSaveButtonState();
        }

        // Update save button state
        function updateSaveButtonState() {
            // Save button is always enabled when connected
        }

        // display message
        function showNotification(title, message, isError = false) {
            toastMessage.textContent = `${title}: ${message}`;
            notificationToast.classList.remove('alert-success', 'alert-error', 'alert-info');

            if (isError) {
                notificationToast.classList.add('alert-error');
            } else if (title === 'Message') {
                notificationToast.classList.add('alert-info');
            } else {
                notificationToast.classList.add('alert-success');
            }

            notificationToast.style.display = 'flex';

            setTimeout(() => {
                notificationToast.style.display = 'none';
            }, 3000);
        }

        // validate and preview
        function validateAndPreviewFile(input) {
            const file = input.files[0];
            fileError.textContent = '';
            bgPreview.classList.add('hidden');
            writeBgButton.disabled = true;
            selectedBackgroundFile = null;

            if (file) {
                // check file type
                if (!file.type.startsWith('image/gif')) {
                    fileError.textContent = 'Please select a GIF image file';
                    input.value = '';
                    return false;
                }

                // check file size (1MB = 1024 * 1024 bytes)
                const maxSize = 1024 * 1024; // 1MB
                if (file.size > maxSize) {
                    fileError.textContent = 'The image file size cannot exceed 1MB';
                    input.value = '';
                    return false;
                }

                // preview image
                const reader = new FileReader();
                reader.onload = function (e) {
                    bgPreview.style.backgroundImage = `url(${e.target.result})`;
                    bgPreview.classList.remove('hidden');
                    selectedBackgroundFile = file;
                    writeBgButton.disabled = false;
                };
                reader.readAsDataURL(file);
            }
            return true;
        }

        // validate and preview avatar
        function validateAndPreviewAvatarFile(input) {
            const file = input.files[0];
            avatarFileError.textContent = '';
            avatarPreview.classList.add('hidden');
            writeAvatarButton.disabled = true;
            selectedAvatarFile = null;

            if (file) {
                // check file type
                if (!file.type.startsWith('image/gif')) {
                    avatarFileError.textContent = 'Please select a GIF image file';
                    input.value = '';
                    return false;
                }

                // check file size (128KB = 128 * 1024 bytes)
                const maxSize = 128 * 1024; // 128KB
                if (file.size > maxSize) {
                    avatarFileError.textContent = 'The image file size cannot exceed 128KB';
                    input.value = '';
                    return false;
                }

                // preview image
                const reader = new FileReader();
                reader.onload = function (e) {
                    avatarPreview.style.backgroundImage = `url(${e.target.result})`;
                    avatarPreview.classList.remove('hidden');
                    selectedAvatarFile = file;
                    writeAvatarButton.disabled = false;
                };
                reader.readAsDataURL(file);
            }
            return true;
        }

        // clear background image
        function clearBackgroundImage() {
            // No longer changes page background
        }

        // connect
        async function connectToDevice() {
            try {
                // request BT
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_ID] }],
                    optionalServices: [SERVICE_ID]
                });

                // connect to GATT
                server = await device.gatt.connect();
                service = await server.getPrimaryService(SERVICE_ID);

                // Update UI
                isConnected = true;
                updateConnectionStatus();
                connectButton.textContent = 'Disconnect';
                connectButton.classList.remove('btn-primary');
                connectButton.classList.add('btn-error');

                // Process the disconnect event
                device.addEventListener('gattserverdisconnected', handleDisconnection);

                showNotification('Success', 'Connected to EchoKit device');

                // Auto-load all configuration
                await loadAllConfiguration();
            } catch (error) {
                console.error('Connection error:', error);
                showNotification('Error', 'Connection error: ' + error.message, true);
            }
        }

        // Disconnect
        async function disconnectFromDevice() {
            if (device && device.gatt.connected) {
                try {
                    await device.gatt.disconnect();
                    showNotification('Message', 'Disconnected from EchoKit');
                } catch (error) {
                    console.error('Disconnect error: ', error);
                    showNotification('Error', 'Disconnect error: ' + error.message, true);
                }
            }
        }

        // process the disconnect event
        function handleDisconnection() {
            isConnected = false;
            updateConnectionStatus();
            connectButton.textContent = 'Connect to EchoKit';
            connectButton.classList.remove('btn-error');
            connectButton.classList.add('btn-primary');
            device = null;
            server = null;
            service = null;
            showNotification('Message', 'EchoKit is disconnected');
        }

        // Update the UI
        function updateConnectionStatus() {
            if (isConnected) {
                statusIndicator.classList.remove('badge-error');
                statusIndicator.classList.add('badge-success');
                connectionStatus.textContent = 'Connected';
                enableControls();
            } else {
                statusIndicator.classList.remove('badge-success');
                statusIndicator.classList.add('badge-error');
                connectionStatus.textContent = 'Disconnected';
                disableControls();
            }
        }

        // Enable all controls
        function enableControls() {
            loadAllButton.disabled = false;
            saveAllButton.disabled = false;
            ssidInput.disabled = false;
            passInput.disabled = false;
            serverUrlInput.disabled = false;
            backgroundImage.disabled = false;
            clearBgButton.disabled = false;
            avatarImage.disabled = false;
            clearAvatarButton.disabled = false;
            controlPanel.classList.remove('opacity-50', 'pointer-events-none');

            // Enable AFE controls
            afeLinearGainRange.disabled = false;
            agcTargetLevelRange.disabled = false;
            agcCompressionGainRange.disabled = false;
        }

        // Disable all controls
        function disableControls() {
            loadAllButton.disabled = true;
            saveAllButton.disabled = true;
            ssidInput.disabled = true;
            passInput.disabled = true;
            serverUrlInput.disabled = true;
            backgroundImage.disabled = true;
            writeBgButton.disabled = true;
            clearBgButton.disabled = true;
            avatarImage.disabled = true;
            writeAvatarButton.disabled = true;
            clearAvatarButton.disabled = true;
            controlPanel.classList.add('opacity-50', 'pointer-events-none');

            // Disable AFE controls
            afeLinearGainRange.disabled = true;
            agcTargetLevelRange.disabled = true;
            agcCompressionGainRange.disabled = true;
            saveAfeLinearGainButton.disabled = true;
            saveAgcTargetLevelButton.disabled = true;
            saveAgcCompressionGainButton.disabled = true;
        }

        // Reads Characteristic
        async function readCharacteristic(characteristicId, inputElement) {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return false;
            }

            try {
                const characteristic = await service.getCharacteristic(characteristicId);
                const value = await characteristic.readValue();

                const decoder = new TextDecoder();
                const stringValue = decoder.decode(value);

                inputElement.value = stringValue;
                return true;
            } catch (error) {
                console.error('Read error: ', error);
                showNotification('Error', 'Read error: ' + error.message, true);
                return false;
            }
        }

        // Load all configuration
        async function loadAllConfiguration() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            loadAllButton.disabled = true;
            loadAllButton.textContent = 'Loading...';

            try {
                await readCharacteristic(SSID_ID, ssidInput);
                await readCharacteristic(PASS_ID, passInput);
                await readCharacteristic(SERVER_URL_ID, serverUrlInput);

                // Load AFE parameters
                await readAfeLinearGain();
                await readAgcTargetLevel();
                await readAgcCompressionGain();

                // Clear all modification marks
                clearFieldModification('ssid', ssidTitle);
                clearFieldModification('pass', passTitle);
                clearFieldModification('url', urlTitle);

                showNotification('Success', 'All configuration loaded');
            } catch (error) {
                console.error('Load configuration failed:', error);
                showNotification('Error', 'Load configuration failed', true);
            } finally {
                loadAllButton.disabled = false;
                loadAllButton.textContent = 'üîÑ Load Configuration';
            }
        }

        // Save all modifications
        async function saveAllModifications() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            saveAllButton.disabled = true;
            saveAllButton.textContent = 'Saving...';

            try {
                let savedCount = 0;
                const hasModifications = Object.values(modifiedFields).some(modified => modified);

                // If no modifications, send all three parameters
                if (!hasModifications) {
                    await writeCharacteristic(SSID_ID, ssidInput.value);
                    await writeCharacteristic(PASS_ID, passInput.value);
                    await writeCharacteristic(SERVER_URL_ID, serverUrlInput.value);
                    savedCount = 3;
                } else {
                    // If there are modifications, only send modified fields
                    if (modifiedFields.ssid) {
                        await writeCharacteristic(SSID_ID, ssidInput.value);
                        clearFieldModification('ssid', ssidTitle);
                        savedCount++;
                    }

                    if (modifiedFields.pass) {
                        await writeCharacteristic(PASS_ID, passInput.value);
                        clearFieldModification('pass', passTitle);
                        savedCount++;
                    }

                    if (modifiedFields.url) {
                        await writeCharacteristic(SERVER_URL_ID, serverUrlInput.value);
                        clearFieldModification('url', urlTitle);
                        savedCount++;
                    }
                }

                showNotification('Success', `Saved ${savedCount} changes`);

                // Try to reset device after saving
                try {
                    saveAllButton.textContent = 'Resetting...';
                    const characteristic = await service.getCharacteristic(RESET_ID);
                    const encoder = new TextEncoder();
                    const data = encoder.encode('RESET');
                    await characteristic.writeValue(data);
                    showNotification('Success', 'Device reset command sent');
                } catch (resetError) {
                    console.error('Reset failed:', resetError);
                    resetNotSupportedModal.showModal();
                }
            } catch (error) {
                console.error('Save modifications failed:', error);
                showNotification('Error', 'Save modifications failed', true);
            } finally {
                saveAllButton.disabled = false;
                saveAllButton.textContent = 'üíæ Save Changes';
            }
        }

        // Reset device
        async function resetDevice() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            resetButton.disabled = true;
            resetButton.textContent = 'Resetting...';

            try {
                const characteristic = await service.getCharacteristic(RESET_ID);
                const encoder = new TextEncoder();
                const data = encoder.encode('RESET');
                await characteristic.writeValue(data);
                showNotification('Success', 'Device reset command sent');
            } catch (error) {
                console.error('Reset failed:', error);
                resetNotSupportedModal.showModal();
            } finally {
                resetButton.disabled = false;
                resetButton.textContent = 'üîÑ Reset';
            }
        }

        // Writes Characteristic
        async function writeCharacteristic(characteristicId, inputValue) {
            if (!isConnected || !service) {
                throw new Error('EchoKit is not connected');
            }

            inputValue = inputValue || '';

            try {
                const characteristic = await service.getCharacteristic(characteristicId);
                const encoder = new TextEncoder();
                const data = encoder.encode(inputValue);
                await characteristic.writeValue(data);
            } catch (error) {
                console.error('Write error:', error);
                throw error;
            }
        }

        async function writeBackgroundImage() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            if (!selectedBackgroundFile) {
                showNotification('Error', 'Please select a background image', true);
                return;
            }

            try {
                const characteristic = await service.getCharacteristic(BACKGROUND_IMAGE_ID);

                const arrayBuffer = await selectedBackgroundFile.arrayBuffer();
                const totalSize = arrayBuffer.byteLength;
                const chunkSize = 512; // BLE limit
                const totalChunks = Math.ceil(totalSize / chunkSize);

                showNotification('Message', `Sending ${totalChunks} data chunks ...`);

                // prevent double clicking
                writeBgButton.disabled = true;
                writeBgButton.textContent = 'Sending data ...';

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, totalSize);
                    const chunk = arrayBuffer.slice(start, end);

                    const packet = new Uint8Array(chunk.byteLength);
                    packet.set(new Uint8Array(chunk), 0);

                    await characteristic.writeValue(packet);

                    const progress = Math.round(((i + 1) / totalChunks) * 100);
                    writeBgButton.textContent = `In progress ... ${progress}%`;

                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // reset the button
                writeBgButton.disabled = false;
                writeBgButton.textContent = 'Set Background';

                showNotification('Success', `Background image uploaded successfully! Sent ${totalChunks} packets, total size ${Math.round(totalSize / 1024)}KB`);

            } catch (error) {
                console.error('Background image error: ', error);

                // reset the button
                writeBgButton.disabled = false;
                writeBgButton.textContent = 'Set Background';

                showNotification('Error', 'Background image error: ' + error.message, true);
            }
        }

        async function writeAvatarImage() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            if (!selectedAvatarFile) {
                showNotification('Error', 'Please select an avatar image', true);
                return;
            }

            try {
                const characteristic = await service.getCharacteristic(AVATAR_IMAGE_ID);

                const arrayBuffer = await selectedAvatarFile.arrayBuffer();
                const totalSize = arrayBuffer.byteLength;
                const chunkSize = 512; // BLE limit
                const totalChunks = Math.ceil(totalSize / chunkSize);

                showNotification('Message', `Sending avatar ${totalChunks} data chunks ...`);

                // prevent double clicking
                writeAvatarButton.disabled = true;
                writeAvatarButton.textContent = 'Sending data ...';

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, totalSize);
                    const chunk = arrayBuffer.slice(start, end);

                    const packet = new Uint8Array(chunk.byteLength);
                    packet.set(new Uint8Array(chunk), 0);

                    await characteristic.writeValue(packet);

                    const progress = Math.round(((i + 1) / totalChunks) * 100);
                    writeAvatarButton.textContent = `In progress ... ${progress}%`;

                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // reset the button
                writeAvatarButton.disabled = false;
                writeAvatarButton.textContent = 'Set Avatar';

                showNotification('Success', `Avatar uploaded successfully! Sent ${totalChunks} packets, total size ${Math.round(totalSize / 1024)}KB`);

            } catch (error) {
                console.error('Avatar error: ', error);

                // reset the button
                writeAvatarButton.disabled = false;
                writeAvatarButton.textContent = 'Set Avatar';

                showNotification('Error', 'Avatar error: ' + error.message, true);
            }
        }

        connectButton.addEventListener('click', async () => {
            if (!isConnected) {
                await connectToDevice();
            } else {
                await disconnectFromDevice();
            }
        });

        loadAllButton.addEventListener('click', () => {
            loadAllConfiguration();
        });

        saveAllButton.addEventListener('click', () => {
            saveAllModifications();
        });

        // Listen for input changes
        ssidInput.addEventListener('input', () => {
            markFieldAsModified('ssid', ssidTitle);
        });

        passInput.addEventListener('input', () => {
            markFieldAsModified('pass', passTitle);
        });

        serverUrlInput.addEventListener('input', () => {
            markFieldAsModified('url', urlTitle);
        });

        writeBgButton.addEventListener('click', () => {
            writeBackgroundImage();
        });

        clearBgButton.addEventListener('click', () => {
            clearBackgroundImage();
            showNotification('Message', 'Background image cleared');
        });

        writeAvatarButton.addEventListener('click', () => {
            writeAvatarImage();
        });

        clearAvatarButton.addEventListener('click', () => {
            avatarPreview.style.backgroundImage = '';
            avatarPreview.classList.add('hidden');
            avatarImage.value = '';
            selectedAvatarFile = null;
            writeAvatarButton.disabled = true;
            showNotification('Message', 'Avatar cleared');
        });

        // Read AFE Linear Gain (string format f32)
        async function readAfeLinearGain() {
            if (!isConnected || !service) return false;
            try {
                const characteristic = await service.getCharacteristic(AFE_LINEAR_GAIN_ID);
                const value = await characteristic.readValue();
                const decoder = new TextDecoder();
                const stringValue = decoder.decode(value);
                const gain = parseFloat(stringValue);
                if (!isNaN(gain)) {
                    afeLinearGainRange.value = Math.round(gain * 10);
                    afeLinearGainValue.textContent = gain.toFixed(1);
                    // Reset title (remove not supported label)
                    afeLinearGainTitle.textContent = 'AFE Linear Gain';
                    saveAfeLinearGainButton.disabled = true;
                }
                return true;
            } catch (error) {
                console.error('Failed to read AFE Linear Gain:', error);
                // Backward compatibility: disable this control
                afeLinearGainRange.disabled = true;
                saveAfeLinearGainButton.disabled = true;
                afeLinearGainTitle.textContent = 'AFE Linear Gain (Not Supported)';
                return false;
            }
        }

        // Read AGC Target Level (i32, 4 bytes little endian)
        async function readAgcTargetLevel() {
            if (!isConnected || !service) return false;
            try {
                const characteristic = await service.getCharacteristic(AGC_TARGET_LEVEL_ID);
                const value = await characteristic.readValue();
                // value is already DataView, use directly
                const level = value.getInt32(0, true);
                agcTargetLevelRange.value = level;
                agcTargetLevelValue.textContent = level;
                // Reset title (remove not supported label)
                agcTargetLevelTitle.textContent = 'AGC Target Level';
                saveAgcTargetLevelButton.disabled = true;
                return true;
            } catch (error) {
                console.error('Failed to read AGC Target Level:', error);
                // Backward compatibility: disable this control
                agcTargetLevelRange.disabled = true;
                saveAgcTargetLevelButton.disabled = true;
                agcTargetLevelTitle.textContent = 'AGC Target Level (Not Supported)';
                return false;
            }
        }

        // Read AGC Compression Gain (i32, 4 bytes little endian)
        async function readAgcCompressionGain() {
            if (!isConnected || !service) return false;
            try {
                const characteristic = await service.getCharacteristic(AGC_COMPRESSION_GAIN_ID);
                const value = await characteristic.readValue();
                // value is already DataView, use directly
                const gain = value.getInt32(0, true);
                agcCompressionGainRange.value = gain;
                agcCompressionGainValue.textContent = gain;
                // Reset title (remove not supported label)
                agcCompressionGainTitle.textContent = 'AGC Compression Gain';
                saveAgcCompressionGainButton.disabled = true;
                return true;
            } catch (error) {
                console.error('Failed to read AGC Compression Gain:', error);
                // Backward compatibility: disable this control
                agcCompressionGainRange.disabled = true;
                saveAgcCompressionGainButton.disabled = true;
                agcCompressionGainTitle.textContent = 'AGC Compression Gain (Not Supported)';
                return false;
            }
        }

        // AFE Linear Gain save function
        async function saveAfeLinearGain() {
            if (!isConnected || !service) {
                showNotification('Error', 'Device not connected', true);
                return;
            }
            try {
                const gain = parseFloat((afeLinearGainRange.value / 10).toFixed(1));
                const characteristic = await service.getCharacteristic(AFE_LINEAR_GAIN_ID);
                const encoder = new TextEncoder();
                const data = encoder.encode(gain.toString());
                await characteristic.writeValue(data);
                showNotification('Success', `AFE Linear Gain set to ${gain}`);
                clearFieldModification('afeLinearGain', afeLinearGainTitle);
                saveAfeLinearGainButton.disabled = true;
            } catch (error) {
                console.error('Failed to save AFE Linear Gain:', error);
                showNotification('Error', 'Failed to save AFE Linear Gain: ' + error.message, true);
            }
        }

        // AGC Target Level save function
        async function saveAgcTargetLevel() {
            if (!isConnected || !service) {
                showNotification('Error', 'Device not connected', true);
                return;
            }
            try {
                const level = parseInt(agcTargetLevelRange.value);
                const characteristic = await service.getCharacteristic(AGC_TARGET_LEVEL_ID);
                const data = new ArrayBuffer(4);
                const view = new DataView(data);
                view.setInt32(0, level, true);
                await characteristic.writeValue(data);
                showNotification('Success', `AGC Target Level set to ${level}`);
                clearFieldModification('agcTargetLevel', agcTargetLevelTitle);
                saveAgcTargetLevelButton.disabled = true;
            } catch (error) {
                console.error('Failed to save AGC Target Level:', error);
                showNotification('Error', 'Failed to save AGC Target Level: ' + error.message, true);
            }
        }

        // AGC Compression Gain save function
        async function saveAgcCompressionGain() {
            if (!isConnected || !service) {
                showNotification('Error', 'Device not connected', true);
                return;
            }
            try {
                const gain = parseInt(agcCompressionGainRange.value);
                const characteristic = await service.getCharacteristic(AGC_COMPRESSION_GAIN_ID);
                const data = new ArrayBuffer(4);
                const view = new DataView(data);
                view.setInt32(0, gain, true);
                await characteristic.writeValue(data);
                showNotification('Success', `AGC Compression Gain set to ${gain}`);
                clearFieldModification('agcCompressionGain', agcCompressionGainTitle);
                saveAgcCompressionGainButton.disabled = true;
            } catch (error) {
                console.error('Failed to save AGC Compression Gain:', error);
                showNotification('Error', 'Failed to save AGC Compression Gain: ' + error.message, true);
            }
        }

        // AFE Linear Gain slider event
        afeLinearGainRange.addEventListener('input', () => {
            const gain = (afeLinearGainRange.value / 10).toFixed(1);
            afeLinearGainValue.textContent = gain;
            markFieldAsModified('afeLinearGain', afeLinearGainTitle);
            saveAfeLinearGainButton.disabled = false;
        });

        // AGC Target Level slider event
        agcTargetLevelRange.addEventListener('input', () => {
            agcTargetLevelValue.textContent = agcTargetLevelRange.value;
            markFieldAsModified('agcTargetLevel', agcTargetLevelTitle);
            saveAgcTargetLevelButton.disabled = false;
        });

        // AGC Compression Gain slider event
        agcCompressionGainRange.addEventListener('input', () => {
            agcCompressionGainValue.textContent = agcCompressionGainRange.value;
            markFieldAsModified('agcCompressionGain', agcCompressionGainTitle);
            saveAgcCompressionGainButton.disabled = false;
        });

        // AFE save button events
        saveAfeLinearGainButton.addEventListener('click', saveAfeLinearGain);
        saveAgcTargetLevelButton.addEventListener('click', saveAgcTargetLevel);
        saveAgcCompressionGainButton.addEventListener('click', saveAgcCompressionGain);

        if (!navigator.bluetooth) {
            showNotification('Error', 'Your browser does not support the Web Bluetooth API. Please use Chrome or Edge', true);
            connectButton.disabled = true;
        }

        // Initialize controls as disabled
        disableControls();
    </script>
</body>

</html>
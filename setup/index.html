<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setup EchoKit</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>

<body class="bg-base-200 min-h-screen py-8 bg-cover bg-center bg-no-repeat bg-fixed">
    <div class="container mx-auto px-4 max-w-4xl">
        <div class="card bg-base-100 shadow-xl">
            <div class="card-body">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="card-title text-2xl">Setup EchoKit via Bluetooth</h2>
                    <div class="flex items-center gap-2">
                        <span class="badge badge-error" id="statusIndicator">‚óè</span>
                        <span id="connectionStatus">Disconnected</span>
                    </div>
                </div>

                <button class="btn btn-primary w-full mb-4" id="connectButton">
                    Connect to EchoKit
                </button>

                <div id="controlPanel" class="space-y-4">
                    <div class="flex gap-2">
                        <button class="btn btn-outline flex-1" id="loadAllButton">
                            üîÑ Load Configuration
                        </button>
                        <button class="btn btn-primary flex-1" id="saveAllButton" disabled>
                            üíæ Save Changes
                        </button>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg" id="ssidTitle">WiFi Network (MUST be 2.4GHz)</h3>
                            <label class="form-control">
                                <div class="label">
                                    <span class="label-text">Network Name</span>
                                </div>
                                <input type="text" id="ssidInput" placeholder="WiFi network name SSID"
                                    class="input input-bordered w-full">
                            </label>
                        </div>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg" id="passTitle">WiFi Password</h3>
                            <label class="form-control">
                                <div class="label">
                                    <span class="label-text">Password</span>
                                </div>
                                <input type="password" id="passInput" placeholder="WiFi Password"
                                    class="input input-bordered w-full">
                            </label>
                        </div>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg" id="urlTitle">EchoKit Server</h3>
                            <label class="form-control">
                                <div class="label">
                                    <span class="label-text">WebSocket URL</span>
                                </div>
                                <input type="text" id="serverUrlInput" placeholder="EchoKit server WebSocket URL"
                                    class="input input-bordered w-full">
                            </label>
                        </div>
                    </div>

                    <div class="card bg-base-100 border border-base-300">
                        <div class="card-body">
                            <h3 class="card-title text-lg">Background Image</h3>
                            <div class="form-control mb-4">
                                <label class="label">
                                    <span class="label-text">Select a background image (GIF)</span>
                                </label>
                                <input type="file" class="file-input file-input-bordered w-full" id="backgroundImage"
                                    accept=".gif" onchange="validateAndPreviewFile(this)">
                                <label class="label">
                                    <span class="label-text-alt">Must be a GIF file, max 1MB</span>
                                </label>
                                <div id="fileError" class="text-error text-sm"></div>
                                <div id="bgPreview"
                                    class="hidden mt-2 w-24 h-16 rounded border border-base-300 bg-cover bg-center">
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button class="btn btn-primary flex-1" id="writeBgButton" disabled>Set
                                    Background</button>
                                <button class="btn btn-outline flex-1" id="clearBgButton">Clear Background</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification toast -->
    <div class="toast toast-top toast-end z-50" id="toastContainer">
        <div class="alert" id="notificationToast" style="display: none;">
            <span id="toastMessage">Message content</span>
        </div>
    </div>

    <!-- Reset not supported modal dialog -->
    <dialog id="resetNotSupportedModal" class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">‚ö†Ô∏è Device Reset Required</h3>
            <p class="py-4">Device does not support this operation, please reset by pressing k0 on the device</p>
            <div class="modal-action">
                <form method="dialog">
                    <button class="btn btn-primary">OK</button>
                </form>
            </div>
        </div>
    </dialog>

    <script>
        // UUIDs
        const SERVICE_ID = "623fa3e2-631b-4f8f-a6e7-a7b09c03e7e0";
        const SSID_ID = "1fda4d6e-2f14-42b0-96fa-453bed238375";
        const PASS_ID = "a987ab18-a940-421a-a1d7-b94ee22bccbe";
        const SERVER_URL_ID = "cef520a9-bcb5-4fc6-87f7-82804eee2b20";
        const BACKGROUND_IMAGE_ID = "d1f3b2c4-5e6f-4a7b-8c9d-0e1f2a3b4c5d";
        const RESET_ID = "f0e1d2c3-b4a5-6789-0abc-def123456789";

        // global variables
        let device = null;
        let server = null;
        let service = null;
        let isConnected = false;
        let toast = null;
        let selectedBackgroundFile = null;

        // DOM
        const connectButton = document.getElementById('connectButton');
        const controlPanel = document.getElementById('controlPanel');
        const statusIndicator = document.getElementById('statusIndicator');
        const connectionStatus = document.getElementById('connectionStatus');
        const loadAllButton = document.getElementById('loadAllButton');
        const saveAllButton = document.getElementById('saveAllButton');
        const ssidInput = document.getElementById('ssidInput');
        const passInput = document.getElementById('passInput');
        const serverUrlInput = document.getElementById('serverUrlInput');
        const ssidTitle = document.getElementById('ssidTitle');
        const passTitle = document.getElementById('passTitle');
        const urlTitle = document.getElementById('urlTitle');
        const backgroundImage = document.getElementById('backgroundImage');
        const bgPreview = document.getElementById('bgPreview');
        const fileError = document.getElementById('fileError');
        const writeBgButton = document.getElementById('writeBgButton');
        const clearBgButton = document.getElementById('clearBgButton');
        const notificationToast = document.getElementById('notificationToast');
        const toastMessage = document.getElementById('toastMessage');
        const resetNotSupportedModal = document.getElementById('resetNotSupportedModal');

        // Track modified fields
        const modifiedFields = {
            ssid: false,
            pass: false,
            url: false
        };

        // Mark field as modified
        function markFieldAsModified(fieldName, titleElement) {
            modifiedFields[fieldName] = true;
            if (!titleElement.textContent.endsWith(' *')) {
                titleElement.textContent += ' *';
            }
            updateSaveButtonState();
        }

        // Clear field modification mark
        function clearFieldModification(fieldName, titleElement) {
            modifiedFields[fieldName] = false;
            titleElement.textContent = titleElement.textContent.replace(' *', '');
            updateSaveButtonState();
        }

        // Update save button state
        function updateSaveButtonState() {
            // Save button is always enabled when connected
        }

        // display message
        function showNotification(title, message, isError = false) {
            toastMessage.textContent = `${title}: ${message}`;
            notificationToast.classList.remove('alert-success', 'alert-error', 'alert-info');

            if (isError) {
                notificationToast.classList.add('alert-error');
            } else if (title === 'Message') {
                notificationToast.classList.add('alert-info');
            } else {
                notificationToast.classList.add('alert-success');
            }

            notificationToast.style.display = 'flex';

            setTimeout(() => {
                notificationToast.style.display = 'none';
            }, 3000);
        }

        // validate and preview
        function validateAndPreviewFile(input) {
            const file = input.files[0];
            fileError.textContent = '';
            bgPreview.classList.add('hidden');
            writeBgButton.disabled = true;
            selectedBackgroundFile = null;

            if (file) {
                // check file type
                if (!file.type.startsWith('image/gif')) {
                    fileError.textContent = 'Please select a GIF image file';
                    input.value = '';
                    return false;
                }

                // check file size (1MB = 1024 * 1024 bytes)
                const maxSize = 1024 * 1024; // 1MB
                if (file.size > maxSize) {
                    fileError.textContent = 'The image file size cannot exceed 1MB';
                    input.value = '';
                    return false;
                }

                // preview image
                const reader = new FileReader();
                reader.onload = function (e) {
                    bgPreview.style.backgroundImage = `url(${e.target.result})`;
                    bgPreview.classList.remove('hidden');
                    selectedBackgroundFile = file;
                    writeBgButton.disabled = false;
                };
                reader.readAsDataURL(file);
            }
            return true;
        }

        // background image
        function applyBackgroundImage(imageDataUrl) {
            document.body.style.backgroundImage = `url(${imageDataUrl})`;
        }

        // clear background image
        function clearBackgroundImage() {
            document.body.style.backgroundImage = '';
        }

        // connect
        async function connectToDevice() {
            try {
                // request BT
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_ID] }],
                    optionalServices: [SERVICE_ID]
                });

                // connect to GATT
                server = await device.gatt.connect();
                service = await server.getPrimaryService(SERVICE_ID);

                // Update UI
                isConnected = true;
                updateConnectionStatus();
                connectButton.textContent = 'Disconnect';
                connectButton.classList.remove('btn-primary');
                connectButton.classList.add('btn-error');

                // Process the disconnect event
                device.addEventListener('gattserverdisconnected', handleDisconnection);

                showNotification('Success', 'Connected to EchoKit device');

                // Auto-load all configuration
                await loadAllConfiguration();
            } catch (error) {
                console.error('Connection error:', error);
                showNotification('Error', 'Connection error: ' + error.message, true);
            }
        }

        // Disconnect
        async function disconnectFromDevice() {
            if (device && device.gatt.connected) {
                try {
                    await device.gatt.disconnect();
                    showNotification('Message', 'Disconnected from EchoKit');
                } catch (error) {
                    console.error('Disconnect error: ', error);
                    showNotification('Error', 'Disconnect error: ' + error.message, true);
                }
            }
        }

        // process the disconnect event
        function handleDisconnection() {
            isConnected = false;
            updateConnectionStatus();
            connectButton.textContent = 'Connect to EchoKit';
            connectButton.classList.remove('btn-error');
            connectButton.classList.add('btn-primary');
            device = null;
            server = null;
            service = null;
            showNotification('Message', 'EchoKit is disconnected');
        }

        // Update the UI
        function updateConnectionStatus() {
            if (isConnected) {
                statusIndicator.classList.remove('badge-error');
                statusIndicator.classList.add('badge-success');
                connectionStatus.textContent = 'Connected';
                enableControls();
            } else {
                statusIndicator.classList.remove('badge-success');
                statusIndicator.classList.add('badge-error');
                connectionStatus.textContent = 'Disconnected';
                disableControls();
            }
        }

        // Enable all controls
        function enableControls() {
            loadAllButton.disabled = false;
            saveAllButton.disabled = false;
            ssidInput.disabled = false;
            passInput.disabled = false;
            serverUrlInput.disabled = false;
            backgroundImage.disabled = false;
            clearBgButton.disabled = false;
            controlPanel.classList.remove('opacity-50', 'pointer-events-none');
        }

        // Disable all controls
        function disableControls() {
            loadAllButton.disabled = true;
            saveAllButton.disabled = true;
            ssidInput.disabled = true;
            passInput.disabled = true;
            serverUrlInput.disabled = true;
            backgroundImage.disabled = true;
            writeBgButton.disabled = true;
            clearBgButton.disabled = true;
            controlPanel.classList.add('opacity-50', 'pointer-events-none');
        }

        // Reads Characteristic
        async function readCharacteristic(characteristicId, inputElement) {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return false;
            }

            try {
                const characteristic = await service.getCharacteristic(characteristicId);
                const value = await characteristic.readValue();

                const decoder = new TextDecoder();
                const stringValue = decoder.decode(value);

                inputElement.value = stringValue;
                return true;
            } catch (error) {
                console.error('Read error: ', error);
                showNotification('Error', 'Read error: ' + error.message, true);
                return false;
            }
        }

        // Load all configuration
        async function loadAllConfiguration() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            loadAllButton.disabled = true;
            loadAllButton.textContent = 'Loading...';

            try {
                await readCharacteristic(SSID_ID, ssidInput);
                await readCharacteristic(PASS_ID, passInput);
                await readCharacteristic(SERVER_URL_ID, serverUrlInput);

                // Clear all modification marks
                clearFieldModification('ssid', ssidTitle);
                clearFieldModification('pass', passTitle);
                clearFieldModification('url', urlTitle);

                showNotification('Success', 'All configuration loaded');
            } catch (error) {
                console.error('Load configuration failed:', error);
                showNotification('Error', 'Load configuration failed', true);
            } finally {
                loadAllButton.disabled = false;
                loadAllButton.textContent = 'üîÑ Load Configuration';
            }
        }

        // Save all modifications
        async function saveAllModifications() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            saveAllButton.disabled = true;
            saveAllButton.textContent = 'Saving...';

            try {
                let savedCount = 0;
                const hasModifications = Object.values(modifiedFields).some(modified => modified);

                // If no modifications, send all three parameters
                if (!hasModifications) {
                    await writeCharacteristic(SSID_ID, ssidInput.value);
                    await writeCharacteristic(PASS_ID, passInput.value);
                    await writeCharacteristic(SERVER_URL_ID, serverUrlInput.value);
                    savedCount = 3;
                } else {
                    // If there are modifications, only send modified fields
                    if (modifiedFields.ssid) {
                        await writeCharacteristic(SSID_ID, ssidInput.value);
                        clearFieldModification('ssid', ssidTitle);
                        savedCount++;
                    }

                    if (modifiedFields.pass) {
                        await writeCharacteristic(PASS_ID, passInput.value);
                        clearFieldModification('pass', passTitle);
                        savedCount++;
                    }

                    if (modifiedFields.url) {
                        await writeCharacteristic(SERVER_URL_ID, serverUrlInput.value);
                        clearFieldModification('url', urlTitle);
                        savedCount++;
                    }
                }

                showNotification('Success', `Saved ${savedCount} changes`);

                // Try to reset device after saving
                try {
                    saveAllButton.textContent = 'Resetting...';
                    const characteristic = await service.getCharacteristic(RESET_ID);
                    const encoder = new TextEncoder();
                    const data = encoder.encode('RESET');
                    await characteristic.writeValue(data);
                    showNotification('Success', 'Device reset command sent');
                } catch (resetError) {
                    console.error('Reset failed:', resetError);
                    resetNotSupportedModal.showModal();
                }
            } catch (error) {
                console.error('Save modifications failed:', error);
                showNotification('Error', 'Save modifications failed', true);
            } finally {
                saveAllButton.disabled = false;
                saveAllButton.textContent = 'üíæ Save Changes';
            }
        }

        // Reset device
        async function resetDevice() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            resetButton.disabled = true;
            resetButton.textContent = 'Resetting...';

            try {
                const characteristic = await service.getCharacteristic(RESET_ID);
                const encoder = new TextEncoder();
                const data = encoder.encode('RESET');
                await characteristic.writeValue(data);
                showNotification('Success', 'Device reset command sent');
            } catch (error) {
                console.error('Reset failed:', error);
                resetNotSupportedModal.showModal();
            } finally {
                resetButton.disabled = false;
                resetButton.textContent = 'üîÑ Reset';
            }
        }

        // Writes Characteristic
        async function writeCharacteristic(characteristicId, inputValue) {
            if (!isConnected || !service) {
                throw new Error('EchoKit is not connected');
            }

            inputValue = inputValue || '';

            try {
                const characteristic = await service.getCharacteristic(characteristicId);
                const encoder = new TextEncoder();
                const data = encoder.encode(inputValue);
                await characteristic.writeValue(data);
            } catch (error) {
                console.error('Write error:', error);
                throw error;
            }
        }

        async function writeBackgroundImage() {
            if (!isConnected || !service) {
                showNotification('Error', 'EchoKit is not connected', true);
                return;
            }

            if (!selectedBackgroundFile) {
                showNotification('Error', 'Please select a background image', true);
                return;
            }

            try {
                const characteristic = await service.getCharacteristic(BACKGROUND_IMAGE_ID);

                const arrayBuffer = await selectedBackgroundFile.arrayBuffer();
                const totalSize = arrayBuffer.byteLength;
                const chunkSize = 512; // BLE limit
                const totalChunks = Math.ceil(totalSize / chunkSize);

                showNotification('Message', `Sending ${totalChunks} data chunks ...`);

                // prevent double clicking
                writeBgButton.disabled = true;
                writeBgButton.textContent = 'Sending data ...';

                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, totalSize);
                    const chunk = arrayBuffer.slice(start, end);

                    const packet = new Uint8Array(chunk.byteLength);
                    packet.set(new Uint8Array(chunk), 0);

                    await characteristic.writeValue(packet);

                    const progress = Math.round(((i + 1) / totalChunks) * 100);
                    writeBgButton.textContent = `In progress ... ${progress}%`;

                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // background image
                const reader = new FileReader();
                reader.onload = function (e) {
                    applyBackgroundImage(e.target.result);
                };
                reader.readAsDataURL(selectedBackgroundFile);

                // reset the button
                writeBgButton.disabled = false;
                writeBgButton.textContent = 'Set Background';

                showNotification('Success', `Background image uploaded successfully! Sent ${totalChunks} packets, total size ${Math.round(totalSize / 1024)}KB`);

            } catch (error) {
                console.error('Background image error: ', error);

                // reset the button
                writeBgButton.disabled = false;
                writeBgButton.textContent = 'Set Background';

                showNotification('Error', 'Background image error: ' + error.message, true);
            }
        }

        connectButton.addEventListener('click', async () => {
            if (!isConnected) {
                await connectToDevice();
            } else {
                await disconnectFromDevice();
            }
        });

        loadAllButton.addEventListener('click', () => {
            loadAllConfiguration();
        });

        saveAllButton.addEventListener('click', () => {
            saveAllModifications();
        });

        // Listen for input changes
        ssidInput.addEventListener('input', () => {
            markFieldAsModified('ssid', ssidTitle);
        });

        passInput.addEventListener('input', () => {
            markFieldAsModified('pass', passTitle);
        });

        serverUrlInput.addEventListener('input', () => {
            markFieldAsModified('url', urlTitle);
        });

        writeBgButton.addEventListener('click', () => {
            writeBackgroundImage();
        });

        clearBgButton.addEventListener('click', () => {
            clearBackgroundImage();
            showNotification('Message', 'Background image cleared');
        });

        if (!navigator.bluetooth) {
            showNotification('Error', 'Your browser does not support the Web Bluetooth API. Please use Chrome or Edge', true);
            connectButton.disabled = true;
        }

        // Initialize controls as disabled
        disableControls();
    </script>
</body>

</html>